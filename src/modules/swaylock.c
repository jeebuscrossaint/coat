#include "swaylock.h"
#include "tinted_parser.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <unistd.h>

// Helper to strip # from hex color if present
static const char* strip_hash(const char *color) {
    return (color[0] == '#') ? color + 1 : color;
}

// Helper to convert opacity to 2-digit hex (00-FF)
static void opacity_to_hex(float opacity, char *out) {
    int alpha = (int)(opacity * 255.0);
    if (alpha > 255) alpha = 255;
    if (alpha < 0) alpha = 0;
    snprintf(out, 3, "%02X", alpha);
}

// Generate swaylock config from a Base16 scheme
int swaylock_generate_config(const Base16Scheme *scheme, const char *output_path, const OpacityConfig *opacity) {
    if (!scheme || !output_path) {
        return -1;
    }
    
    FILE *f = fopen(output_path, "w");
    if (!f) {
        fprintf(stderr, "Failed to create swaylock config: %s\n", output_path);
        return -1;
    }
    
    // Determine variant
    int is_light = (scheme->variant[0] && strstr(scheme->variant, "light") != NULL);
    
    // Write header
    fprintf(f, "# Swaylock configuration\n");
    fprintf(f, "# Generated by coat\n");
    fprintf(f, "# Theme: %s\n", scheme->name);
    fprintf(f, "# Author: %s\n", scheme->author);
    if (scheme->variant[0]) {
        fprintf(f, "# Variant: %s\n", scheme->variant);
    }
    fprintf(f, "\n");
    
    // Get alpha value for popups
    char alpha[3] = "FF";
    if (opacity && opacity->popups < 1.0) {
        opacity_to_hex(opacity->popups, alpha);
    }
    
    // Background color (base00 for dark, base07 for light)
    fprintf(f, "# Background\n");
    fprintf(f, "color=%s%s\n", strip_hash(scheme->base00), alpha);
    fprintf(f, "\n");
    
    // Show failed attempts
    fprintf(f, "# General settings\n");
    fprintf(f, "show-failed-attempts\n");
    fprintf(f, "indicator-radius=100\n");
    fprintf(f, "indicator-thickness=7\n");
    fprintf(f, "\n");
    
    // Ring colors (different states)
    fprintf(f, "# Ring colors\n");
    fprintf(f, "ring-color=%s\n", strip_hash(is_light ? scheme->base03 : scheme->base03));
    fprintf(f, "ring-clear-color=%s\n", strip_hash(scheme->base0C));
    fprintf(f, "ring-caps-lock-color=%s\n", strip_hash(scheme->base09));
    fprintf(f, "ring-ver-color=%s\n", strip_hash(scheme->base0D));
    fprintf(f, "ring-wrong-color=%s\n", strip_hash(scheme->base08));
    fprintf(f, "\n");
    
    // Inside colors (circle fill)
    fprintf(f, "# Inside colors\n");
    fprintf(f, "inside-color=%s\n", strip_hash(scheme->base00));
    fprintf(f, "inside-clear-color=%s\n", strip_hash(scheme->base00));
    fprintf(f, "inside-caps-lock-color=%s\n", strip_hash(scheme->base00));
    fprintf(f, "inside-ver-color=%s\n", strip_hash(scheme->base00));
    fprintf(f, "inside-wrong-color=%s\n", strip_hash(scheme->base00));
    fprintf(f, "\n");
    
    // Line colors (between ring and inside)
    fprintf(f, "# Line colors (separator)\n");
    fprintf(f, "line-color=%s\n", strip_hash(scheme->base01));
    fprintf(f, "line-clear-color=%s\n", strip_hash(scheme->base01));
    fprintf(f, "line-caps-lock-color=%s\n", strip_hash(scheme->base01));
    fprintf(f, "line-ver-color=%s\n", strip_hash(scheme->base01));
    fprintf(f, "line-wrong-color=%s\n", strip_hash(scheme->base01));
    fprintf(f, "\n");
    
    // Text colors
    fprintf(f, "# Text colors\n");
    fprintf(f, "text-color=%s\n", strip_hash(scheme->base05));
    fprintf(f, "text-clear-color=%s\n", strip_hash(scheme->base0C));
    fprintf(f, "text-caps-lock-color=%s\n", strip_hash(scheme->base09));
    fprintf(f, "text-ver-color=%s\n", strip_hash(scheme->base0D));
    fprintf(f, "text-wrong-color=%s\n", strip_hash(scheme->base08));
    fprintf(f, "\n");
    
    // Key highlight colors
    fprintf(f, "# Key highlight colors\n");
    fprintf(f, "key-hl-color=%s\n", strip_hash(scheme->base0B));
    fprintf(f, "bs-hl-color=%s\n", strip_hash(scheme->base08));
    fprintf(f, "caps-lock-key-hl-color=%s\n", strip_hash(scheme->base09));
    fprintf(f, "caps-lock-bs-hl-color=%s\n", strip_hash(scheme->base08));
    fprintf(f, "\n");
    
    // Separator color
    fprintf(f, "# Separator color\n");
    fprintf(f, "separator-color=%s\n", strip_hash(scheme->base02));
    fprintf(f, "\n");
    
    // Layout colors (keyboard layout indicator)
    fprintf(f, "# Layout indicator colors\n");
    fprintf(f, "layout-bg-color=%s\n", strip_hash(scheme->base01));
    fprintf(f, "layout-border-color=%s\n", strip_hash(scheme->base03));
    fprintf(f, "layout-text-color=%s\n", strip_hash(scheme->base05));
    fprintf(f, "\n");
    
    fclose(f);
    return 0;
}

// Apply swaylock theme to current swaylock configuration
int swaylock_apply_theme(const Base16Scheme *scheme, const OpacityConfig *opacity) {
    if (!scheme) {
        return -1;
    }
    
    const char *home = getenv("HOME");
    if (!home) {
        fprintf(stderr, "Could not determine home directory\n");
        return -1;
    }
    
    // Create swaylock config directory if it doesn't exist
    char config_dir[1024];
    snprintf(config_dir, sizeof(config_dir), "%s/.config/swaylock", home);
    mkdir(config_dir, 0755);
    
    // Generate config file
    char config_path[1024];
    snprintf(config_path, sizeof(config_path), "%s/config", config_dir);
    
    printf("Generating swaylock config: %s\n", config_path);
    
    if (swaylock_generate_config(scheme, config_path, opacity) != 0) {
        return -1;
    }
    
    printf("Swaylock config generated successfully!\n");
    printf("\nSwaylock will use the new theme on next lock.\n");
    printf("\nTo test:\n");
    printf("  swaylock\n");
    printf("\nOr add to your Sway config to bind to a key:\n");
    printf("  bindsym $mod+l exec swaylock\n");
    printf("\nFor auto-lock on idle:\n");
    printf("  exec swayidle -w \\\n");
    printf("    timeout 300 'swaylock -f' \\\n");
    printf("    timeout 600 'swaymsg \"output * dpms off\"' \\\n");
    printf("    resume 'swaymsg \"output * dpms on\"' \\\n");
    printf("    before-sleep 'swaylock -f'\n");
    printf("\nSee USAGE.md for more details.\n");
    
    return 0;
}
